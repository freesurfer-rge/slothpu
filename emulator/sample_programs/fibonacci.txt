# Fibonacci

# Computes Fibonacci numbers using a two byte accumulator
# This limits us to the first 20 or so, so the input is a singl
# byte






# -----------------------------------------------------

# Subroutine to add two 2-byte numbers
# We can assume that R7 is set for our stackframe
# The first four bytes are
# a_lo, a_hi, b_lo, b_hi
# We then need to put result_lo and result_hi into
# the next two bytes

84 REG SET000 R6

# Load the two low bytes into R1 and R2
86 MEM LOAD R6 R7 R1
88 SALU INC R6 R6
90 SALU INC R6 R6
92 MEM LOAD R6 R7 R2

# Add the two low bytes store in R3
94 DALU ADD R1 R2 R3
# Grab the status register
96 REG LOADSTATUS R4

# Now store R4 into the low byte of the answer
98 SALU INC R6 R6
100 SALU INC R6 R6
102 MEM STORE R6 R7 R3

# Mask the status register for the DALU flag
# DALU flag is in the second bit of the status register
104 REG SET002 R2
106 DALU AND R2 R4 R4 # R4 now just holds the carry bit

# Now we add the two high bytes into R1 and R2
108 REG SET001 R6
110 MEM LOAD R6 R7 R1
112 SALU INC R6 R6
114 SALU INC R6 R6
116 MEM LOAD R6 R7 R2

# Do R1 + R2 -> R3
118 DALU ADD R1 R2 R3

# If we had a carry from the low byte
# we need to increment
120 REG SET000 R0
122 REG SET128 R1 # First instruction past the INC
124 PC JUMPZERO R1 R0 R4  # Test the carry bit
126 SALU INC R3 R3

# Save out the high byte
128 SALU INC R6 R6
130 SALU INC R6 R6
132 MEM STORE R6 R7 R3

# Finally, return
134 PC RET

# -----------------------------------------------------

# Fibonacci Subroutine

# Takes a single byte argument and returns a 2-byte
# number

# We assume that R7 has been set to our stackframe
# The frame itself will look like:
# 0: n (input value)
# 1: result_lo
# 2: result_hi

# We will use R6 to complete the stack pointer
nnn REG SET000 R6

# Load our argument into R0
nnn MEM LOAD R6 R7 R0

# Pre-emptively set the result to be 1
nnn SALU INC R6 R6
nnn REG SET001 R1
nnn MEM SET R6 R7 R1
nnn SALU INC R6 R6
nnn REG SET000 R1
nnn MEM SET R6 R7 R1

# Set a branch register
nnn REG SETxxx R1

# Test to see if our argument is zero
# If so, branch to the end
nnn PC BRANCHZERO R0 R1

# See if the argument was 1. Do This
# by decrementing and testing for zero
# Also need to update the branch register
nnn REG SETxxx R1
nnn SALU DEC R0 R0
nnn PC BRANCHZERO R0 R1

# If we've got here, we need to Computes
# F(n-1) and F(n-2)
# Remember that R0 is holding the argument
# but we've just decremented it, so that
# part is helpfully ready

# Set R7 to the new stack frame
nnn SALU INC R7 R7

# Reset R6
nnn REG SET000 R6

# Copy R0 (currently n-1) to the stack frame
nnn MEM STORE R6 R7 R0

# Setup the recursive call
nnn REG SETxxx R0
nnn REG SETxxx R1

# Make the call
nnn PC JSR R0 R1

# Load the result into our registers
nnn REG SET001 R6
nnn MEM LOAD R6 R7 R0
nnn SALU INC R6 R6
nnn MEM LOAD R6 R7 R1

# Reset R7 back to being our stack frame
nnn SALU DEC R7 R7

# Store the first result into our stack frame
# The space for this starts at location 003
nnn REG SET003 R6
nnn MEM STORE R6 R7 R0
nnn SALU INC R6 R6
nnn MEM STORE R6 R7 R1

# Now we need to set up the second recursive call
# First work out what the argument will be
# by loading up our argument to R0 and decrementing
# twice
nnn REG SET000 R6
nnn MEM LOAD R6 R7 R0
nnn SALU DEC R0 R0 # Get to n-1
nnn SALU DEC R0 R0 # Get to n-2

# Set R7 to the new stack frame
nnn SALU INC R7 R7

# Copy R0 (currently n-2) to the stack frame
nnn MEM STORE R6 R7 R0

# Setup the recursive call
nnn REG SETxxx R0
nnn REG SETxxx R1

# Make the call
nnn PC JSR R0 R1

# Load the result into our registers
nnn REG SET001 R6
nnn MEM LOAD R6 R7 R0
nnn SALU INC R6 R6
nnn MEM LOAD R6 R7 R1

# Reset R7 back to being our stack frame
nnn SALU DEC R7 R7

# Store the first result into our stack frame
# The space for this starts at location 005
nnn REG SET005 R6
nnn MEM STORE R6 R7 R0
nnn SALU INC R6 R6
nnn MEM STORE R6 R7 R1

# Next, we need to do the Addition
# The current state of our stackframe
# (beginning at R7) is
# 0: n
# 1: result_lo (unset)
# 2: result_hi (unset)
# 3: F(n-1)_lo
# 4: F(n-1)_hi
# 5: F(n-1)_lo
# 6: F(n-1)_hi